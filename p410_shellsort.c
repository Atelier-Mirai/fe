// アメリカの計算機科学者 ドナルド・Ｌ・シェル が考案した整列アルゴリズム
// アルゴリズムの基本は挿入ソートと同じである。挿入ソートは「ほとんど整列されたデータに対しては高速」という長所を持つが、隣接した要素同士しか比較・交換を行わないため、あまり整列されていないデータに対しては低速であった。
// シェルソートは、「飛び飛びの列を繰り返しソートして、配列を大まかに整列された状態に近づけていく」ことにより、挿入ソートの長所を活かしたものである。
// アルゴリズムの概略は次のとおりである。
// 適当な間隔 h を決める（hの決め方については後述）
// 間隔 h をあけて取り出したデータ列に挿入ソートを適用する
// 間隔 h を狭めて、2.を適用する操作を繰り返す
// h=1 になったら、最後に挿入ソートを適用して終了
//
// 平均計算時間は O(n^1.25)で、個数の1.25乗に比例する。(Wikipedia)

// シェルソート コードは
// 改定新版 C言語による標準アルゴリズム事典 p418より引用
void shellsort(int n, int a[]){
  int h, i, j;
  int x;

  h = 13;
  while (h < n) {
    h = 3 * h + 1;  // 1, 4, 13, 40, 121, 364, 1093, 3280, 9841 ...
  }

  // https://programming-place.net/ppp/contents/algorithm/sort/005.html
  // シェルソートでは、間隔 h の決め方が重要になってきます。
  //
  // h = 4, 2, 1 とするのは、あまり良い選び方ではありません。これが良くない理由は、ソートの対象として同じ位置の要素ばかりが選択されてしまい、データ列全体を満遍なくソートできていないからです。
  //
  // たとえば、array[0] を含む組み合わせは、h = 4 のときには [0][4][8] で、h = 2 のときには [0][2][4][6][8] です。また、array[1] を含む組み合わせは、h = 4 のときには [1][5][9] で、h = 2 のときには [1][3][5][7][9] となります。
  //
  // これをよく見ると分かるように、偶数番目の要素同士、奇数番目の要素同士で組を作っていることが分かります。これでは、互いが混ざり合ってソートされることが h = 1 になるまで起こりませんから、h = 1 になった時点で、「ほぼ整列済みになっている」という期待が、成り立ちにくくなってしまいます。
  //
  // そこで、「hn+1 = 3hn + 1」という漸化式で生成した数列「1, 4, 13, 40, 121, 364, 1093, 3280, 9841, ...」を使う例がよく示されます。この数列は、1 から始まり、それ以降は 3倍して +1 したものです。この数列に登場する値を h として選ぶと、良い結果が得られることが知られています。(平均計算量 O(n^1.25), 最悪計算量 O(n^1.5))
  //
  // 例えば、要素数 2000 の配列に対しては、h の値を 1, 4, 13, 121, 364, 1093, 3280と増大させて行きます。
  //
  // 要素数に対して、h の値が大きすぎると、あまりにも遠く離れた、ごく少数の要素同士のソートにしかならず、効果が薄い可能性があります。そのため、要素数に比べて間隔が広すぎるような h は使わない方が良いとされることもあります。
  //
  // そこで、「要素数 / 9」を超えないように h を選ぶという方針を採ることがあります(＝少なくとも九つの要素を含むグループに分割して並び替えを行うようにする)。要素数が 2000 であるとすると、「2000 / 9 = 222」なので、h の値として 3280 や 1093 では大きすぎるので、h = 364, 121, 13, 4, 1 でソートすると効率が良い（のではないか）ということになります。

  // そこで、先に得られた、3280 を 9 で割り、h=364からソートを開始します。
  h /= 9;

  // 秋田高専 竹下研究室
  // https://www2.akita-nct.ac.jp/take/note/algo4e/algo4e.html
  // にも役立つ解説があります。

  while (h > 0){

    // h = 1 なら 挿入ソートと全く同じ
    for (i = h; i < n; i++){
      x = a[i];
      for (j = i - h; j >= 0 && a[j] > x; j -= h){
        a[j + h] = a[j];
      }
      a[j + h] = x;
    }

    h /= 3;
  }
}
