// ヒープソート
// 改定新版 C言語による標準アルゴリズム事典 p222-223より引用
// 
// 「ヒープ」とは、次のような「木」である。
//
// 　　　　　　　　 1
// 　　　　　　　  ／＼
// 　　　　　　　／　　＼
// 　　　　  2 ／\　    3/\
// 　　　　　／　 \　   /  \
// 　　   4／＼　 5\  6/   7\
// 　　　／　　＼　　
//    8／　　   9＼
//
// 木の節点に付けた番号は配列の添字である。この例では a1が根、a5, a6, a7, a8, a9 が葉である。
// 　このような木で、根に近い要素ほど値が大きい（例えばa1 >= a2 >= a4 >= a8）という条件を満たすものをここではヒープと呼ぶ。なお、節点a[i]の子はa[2i]とa[2i+1]であり、逆に節点a[j]の親はa[j/2]である。したがってヒープの条件はa[j] <= a[j/2] (j = 2, 3, ..., n)のように書ける。
// 　このようなヒープを構成するには次のようにする。まず一つの要素a[i]に注目する。この要素の子はa[2i]とa[2i+1]である。この二つのうち大きいほうをa[j]と名付ける。a[i]は自分自身とこのa[j]を比べ、もし自分の方が小さければa[j]と位置を交代する。位置を交代した場合、新しい場所でa[i]はまた自分の子a[2i]とa[2i+1]を見比べ、大きい方をa[j]と名付け、それが自分より大きければ位置を交代する。同様のことを、子がなくなるか、どちらの子も自分より小さくなるまで続ける。上記のことを葉ではない全ての節点a[n/2],...,a[1]について行うと、「どの親も子より大きい」という関係ができ上がり、結局a[1]が最大値になる。
// 　ここまでが、次のプログラムの前半である。
//
// 　後半では、こうして見つけた最大値a[1]を配列の最後の要素a[n]と交換する。すると、最初のn-1個の要素のうちa[1]だけが「どの親も子より大きい」という関係を満たさなくなるので、アルゴリズムの前半と同様のことをi=1についてやり直す。こうして a[1], ..., a[n-1] の最大値をa[1]の位置に来させ、これをa[n-1]と交換すれば、a[n-1]が2番目に大きい要素となる。以下同様に続ければ全体が昇順に並ぶ。
//
// 　親子関係は、たかだか log2 n 代しか続かないので、実行時間は O(n log n) である。
//
// ヒープソートでは、添字を 1 から始めるほうが自然である。


// a[1] ~ a[n] を 昇順に整列する(a[1] <= a[2] <= ... <= a[n] となるように並び替える)
void heapsort(int n, int a[]){
  int i, j, k;
  int x;

  // 二分木（ヒープ）を構築する。a[1]が最大値となる。
  for (k = n / 2; k >= 1; k--){
    i = k;
    x = a[i];
    while ((j = 2 * i) <= n){
      if (j < n && a[j] < a[j + 1]){
        j++;
      }
      if (x >= a[j]) {
        break;
      }
      a[i] = a[j];
      i = j;
    }
    a[i] = x;
  }

  // 最大値a[1]を配列の最後の要素a[n]と交換、木の再構築を繰り返す。
  while (n > 1){
    x    = a[n];
    a[n] = a[1];
    n--;

    i = 1;
    while ((j = 2 * i) <= n){
      if (j < n && a[j] < a[j + 1]){
        j++;
      }
      if (x >= a[j]) {
        break;
      }
      a[i] = a[j];
      i = j;
    }
    a[i] = x;
  }
}
