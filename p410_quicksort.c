// クイックソート
// 改定新版 C言語による標準アルゴリズム事典 p56-57より引用

// 1. 適当なxを選ぶ。その際、配列のx以下の要素の数とx以上の要素の数がなるべく同程度になるようにする。
// 2. x以下の要素を配列の前半に、x以上の要素を配列の後半に集める。
// 3. 配列の前半が長さ2以上なら、配列の前半をクイックソートする。
// 4. 配列の後半が長さ2以上なら、配列の後半をクイックソートする。
// のように、配列の大きさを次々に約半分にして、自分自身を再帰的に適用する（分割統治法）。
//
// 配列が次々に二分される様子
//
// <---------------------  要素数 n の配列 ----------------------->
// (                                                              ) ^
// (                              )(                              ) |
// (              )(              )(              )(              ) | log2 n
// (      )(      )(      )(      )(      )(      )(      )(      ) |
// (  )(  )(  )(  )(  )(  )(  )(  )(  )(  )(  )(  )(  )(  )(  )(  ) v
//
// したがって、実行時間は、ほぼ n log n に比例する

void quicksort(int a[], int first, int last){
  int i, j;
  int x;  // 分割用の枢軸(ピボット)
  int w;  // 作業用変数

  x = a[(first + last) / 2];  // 配列の中央値
  i = first;
  j = last;
  for ( ; ; ) {
    while (a[i] < x) {
      i++;
    }
    while (x < a[j]) {
      j--;
    }
    if (i >= j) {
      break;
    }

    // a[i]とa[j]を交換する
    w    = a[i];
    a[i] = a[j];
    a[j] = w;

    i++;
    j--;
  }

  // 再帰呼び出し
  if (first < i - 1) {
    quicksort(a, first, i - 1);
  }
  if (j + 1 < last) {
    quicksort(a, j + 1, last);
  }
}
